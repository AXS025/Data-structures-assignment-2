#Part A:
class BSTNode: #class for a node in a binary search tree (BST)
    def __init__(self, datetime_value, post): #constructor to initialize node with datetime value and post content
        self.datetime_value = datetime_value
        self.post = post
        self.left = None
        self.right = None

class BinarySearchTree: #BST class
    def __init__(self):
        self.root = None #empty root

    def insert(self, datetime_value, post):  #method to insert a node into the BST
        if not self.root: #If the tree is empty set the new node to root
            self.root = BSTNode(datetime_value, post)
        else: #else add the node in tree
            self._insert_recursive(self.root, datetime_value, post)

    def _insert_recursive(self, node, datetime_value, post): #method to insert a node recursively
        if datetime_value < node.datetime_value: #condition to check datetime value less than node value
            if not node.left: #if the left child of the current node is None then insert the new node as the left child
                node.left = BSTNode(datetime_value, post)
            else: #if the left child exists, recursively call _insert_recursive on the left child
                self._insert_recursive(node.left, datetime_value, post)
        else:  #if the datetime value is greater than or equal to the current node's datetime value
            if not node.right: #if the right child of the current node is None then insert the new node as the right child
                node.right = BSTNode(datetime_value, post)
            else: #if the right child exists then recursively call _insert_recursive on the right child
                self._insert_recursive(node.right, datetime_value, post)

class SocialHashTable: #class for a hash table for social media posts
    def __init__(self): #constructor to initialize the hash table with an empty dictionary
        self.table = {} #dictionary to add values

    def insert(self, key, value): #method to insert values into the hash table
        self.table[key] = value

    def get(self, key): #method to get value based on a key from the hash table
        return self.table.get(key, None)

class Post: #class for a social media posts
    def __init__(self): #constructor to initialize the post attributes
        self.posts_by_datetime = SocialHashTable() #hash table to store posts by datetime
        self.bst = BinarySearchTree() #calling BST class
        self.posts_by_views = [] #list for the posts
        self.view_count = 0 #counter, initilizes by 0

    def add_post(self, datetime_value, person_name, post_content, views): #method to add a post with datetime, person name, content, and views
        self.posts_by_datetime.insert(datetime_value, {'name': person_name, 'content': post_content, 'views': views})
        self.bst.insert(datetime_value, {'name': person_name, 'content': post_content, 'views': views})

    def find_post_by_datetime(self, datetime_value): #method to find post by date and time
        return self.posts_by_datetime.get(datetime_value)

    def find_posts_in_time_range(self, start_datetime, end_datetime): #method to find posts within a time range
        posts_in_range = []
        self._search_range(self.bst.root, start_datetime, end_datetime, posts_in_range)
        return posts_in_range

    def _search_range(self, node, start_datetime, end_datetime, result): #method to search post in range from BST
        if not node:
            return
        if start_datetime <= node.datetime_value <= end_datetime: #if datetime is less than node datetime and end datetime append in list
            result.append(node.post)
        if start_datetime < node.datetime_value: #if input value is less than node value search in left
            self._search_range(node.left, start_datetime, end_datetime, result)
        if end_datetime > node.datetime_value:  #if input value is greater than node value search in right
            self._search_range(node.right, start_datetime, end_datetime, result)

    def add_post_with_views(self, views, post_content, person_name):#method to add post with views
        self.view_count += 1
        self._heap_insert((-views, self.view_count, post_content, person_name))

    def _heap_insert(self, item):#method to insert value in heap
        self.posts_by_views.append(item)
        self._max_heapify_up(len(self.posts_by_views) - 1)

    def _max_heapify_up(self, index):#method of heaify up to take highest node to the root
        parent_index = (index - 1) // 2
        while parent_index >= 0 and self.posts_by_views[parent_index][0] > self.posts_by_views[index][0]: #while loop to check the root node and its views
            self.posts_by_views[parent_index], self.posts_by_views[index] = self.posts_by_views[index], self.posts_by_views[parent_index] #swaps the node with parent node that is the property of heap
            index = parent_index #sets parent index to index
            parent_index = (index - 1) // 2

    def get_post_with_most_views(self): #method to get post with most views
        if self.posts_by_views:
            return self.posts_by_views[0][2], self.posts_by_views[0][3]
        else:
            return None

manager = Post() #object for post class

#Posts in post class
manager.add_post('2024-03-19 10:00:00', 'Alyazy', 'Hello!', 10)
manager.add_post('2024-03-19 12:00:00', 'Shatha', 'Hey', 15)
manager.add_post('2024-03-20 08:00:00', 'Afra', 'Hii', 20)
manager.add_post('2024-03-22 08:00:00', 'Mera', 'Bye!', 20)

#finds post by date and time
print("Finding post by datetime:")
print(manager.find_post_by_datetime('2024-03-19 10:00:00'))
print(manager.find_post_by_datetime('2024-03-19 12:00:00'))

#finds post in a time range
print("Finding posts in time range:")
print(manager.find_posts_in_time_range('2024-03-19 09:00:00', '2024-03-20 12:00:00'))

#posts with views
manager.add_post_with_views(300, 'Lets go!', 'Khalifa')
manager.add_post_with_views(500, 'New home!', 'Mariam')

#prints post with most views
print("Post with most views:")
print(manager.get_post_with_most_views())

#TEST CASES FOR PART A ARE INCLUDED IN THE PDF

#PART B:1.1
#Importing needed libraries of python 
import networkx as nx #for graph operations
import random #for generating random values
import matplotlib.pyplot as plt #for ploting

def generate_road_network(num_intersections, num_roads): #function to generate a road network graph
    G = nx.Graph() #creates an empty graph

    for i in range(num_intersections): #create intersections
        G.add_node(i, type='intersection', id=i) #adds intersection nodes to the graph

    for i in range(num_roads): #creates roads
        #randomly picks start/end intersections for each road
        start = random.randint(0, num_intersections - 1) #start
        end = random.randint(0, num_intersections - 1) #end
        while start == end or G.has_edge(start, end): #makes sure no self loops/parallel edges
            end = random.randint(0, num_intersections - 1)
        length = random.randint(5, 100) #random length for the road
        congestion = random.uniform(5, 50)  #random congestion level for the road
        road_id = i
        road_name = "Street" + str(i)
        G.add_edge(start, end, id=road_id, name=road_name, length=length, congestion=congestion) #adds road edges to the graph

    return G
